// use directive (#) to tell compiler to use Std class.
//% use("Std.kj")
//% use("Math.kj")

// in Kaiju everything is an object of some class (#), so class is your God now.
/*# Program : Object
{
	// static (~) class field ($).
	// this is equivalent to: hello = new String("Hello World!");
	~$ hello = "Hello World!";

	// static (~) class method (@).
	// Main always comes with array of program arguments as parameters.
	~@ Main(argv)
	{
		// just usual function call.
		Std.WriteLine(hello);
		
		// declare local variables ($).
		$ a = Int.parse(argv.Get(1));
		$ b = Int.Parse(argv.Get(2));
		$ result = Add(a, b);
		
		Std.WriteLine(result);
		
		// you can return value, otherwise method will return null,
		// which is default value of any object.
		return result;
	}

	// This method is wrapper for low-level assembler operation.
	~@ Add(a, b)
	{
		// make sure that arguments have proper types.
		% ensureType(a, Int)
		% ensureType(b, Int)

		$ result = 0;

		// here we inject Intuicio Assembler code.
		// get values from managed objects to registry, perform operation and return result.
		% inject("movi regi:0 *:$a->Int.value")
		% inject("movi regi:1 *:$b->Int.value")
		% inject("addi 2 0 1")
		% inject("movi *:$result->Int.value regi:2")

		return result;
	}
}*/
